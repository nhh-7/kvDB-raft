# 协程库

## `fd_manager.hpp` 

包括 `FdCtx`封装单个文件描述符（尤其是 socket) 的各种状态与属性、`FdManager` 持有一个文件句柄集合

## `hook.hpp` 

将系统调用（如 sleep、read、write、connect 等）“劫持”到自定义的协程调度器上，以便协程在遇到阻塞操作时不阻塞整个线程，而是挂起当前协程并调度其他协程继续执行

## `mutex.hpp`

封装了各种锁机制

## `thread.hpp`

一个自封装的 线程类 Thread, 提供 创建线程、获取当前线程的 Thread 对象等功能

## `timer.hpp` 

包含`Timer`-封装一个定时器对象， `TimerManager`-定时器管理器，用于管理所有定时器的生命周期和调度。

## `utils.hpp` 

提供了与线程、时间、断言、调用栈（`Backtrace`）等相关的 工具函数

## `scheduler.hpp`

协程调度器, 包含`SchedulerTask`-对一个任务的封装（可以是函数、可以是协程），`Scheduler`-N->M协程调度器，即通过N个线程的线程池调度M个任务

## `fiber.hpp`

封装单个协程，包括协程上下文(`ucontext_t`)，协程栈地址，协程回调函数

## `iomanager.hpp`



## 协程模块

协程和函数的不同之处是，函数一旦被调用，只能从头开始执行，直到函数执行结束退出，而协程则可以执行到一半就退出（称为yield），但此时协程并未真正结束，只是暂时让出CPU执行权，在后面适当的时机协程可以重新恢复运行（称为resume），在这段时间里其他的协程可以获得CPU并运行

协程能够半路yield、再重新resume的关键是协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文。**协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值**，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。

所谓创建协程，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓协程调度，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；所谓IO协程调度，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；所谓定时器，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。

非对称协程：每个协程只需要运行自己的入口函数，然后结束时将运行权交回给调度器，由调度器来选出下一个要执行的协程即可。

协程是在线程里运行的，不同线程的协程相互不影响，每个线程都要独自处理当前线程的协程切换问题。

协程状态为 READY，代表就绪态，RUNNING，代表正在运行，TERM，代表运行结束

对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是resume，表示恢复协程运行，一种是yield，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。

  `static thread_local Fiber *cur_fiber = nullptr; ` 当前线程正在运行的协程 ；必须时刻指向当前正在运行的协程对象

  `static thread_local Fiber::ptr cur_thread_fiber = nullptr;`  当前线程的主协程； 协程模块初始化时，`t_thread_fiber`指向线程主协程对象。当子协程`resume`时，通过`swapcontext`将主协程的上下文保存到t_thread_fiber的`ucontext_t`成员中，同时激活子协程的`ucontext_t`上下文。当子协程`yield`时，从`t_thread_fiber`中取得主协程的上下文并恢复运行。

`Fiber`提供两个构造函数，带参数的构造函数用于构造子协程，初始化子协程的`ucontext_t`上下文和栈空间，要求必须传入协程的入口函数，以及可选的协程栈大小。不带参的构造函数用于初始化当前线程的协程功能，构造线程主协程对象。这个构造函数被定义成私有方法，不允许在类外部调用，只能通过`GetThis`()方法，在返回当前正在运行的协程时，如果发现当前线程的主协程未被初始化，那就用不带参的构造函数初始化线程主协程。

在非对称协程里，执行resume时的当前执行环境一定是位于线程主协程里，而执行yield时，当前执行环境一定是位于子协程里。

## 协程调度模块

对于协程调度器来说，协程当然可以作为调度任务，但实际上，函数也应可以，因为函数也是可执行的对象，调度器应当支持直接调度一个函数。这在代码实现上也很简单，只需要将函数包装成协程即可，协程调度器的实现重点还是以协程为基础。

能不能把调度器所在的线程（称为caller线程）也加入进来作为调度线程呢？比如典型地，在main函数中定义的调度器，能不能把main函数所在的线程也用来执行调度任务呢？答案是肯定的，在实现相同调度能力的情况下（指能够同时调度的协程数量），线程数越小，线程切换的开销也就越小，效率就更高一些，所以，调度器所在的线程，也应该支持用来执行调度任务。甚至，调度器完全可以不创建新的线程，而只使用caller线程来进行协程调度，比如只使用main函数所在的线程来进行协程调度。

调度器内部维护一个任务队列和一个调度线程池。调度器start()，初始化线程池。开始调度(run)后，线程池从任务队列里按顺序取任务执行。调度线程可以包含caller线程。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。

协程调度器的初始化：初始化时支持传入线程数和一个布尔型的use_caller参数，表示是否使用caller线程。在使用caller线程的情况下，线程数自动减一，并且调度器内部会初始化一个属于caller线程的调度协程并保存起来（比如，在main函数中创建的调度器，如果use_caller为true，那调度器会初始化一个属于main函数线程的调度协程）。

调度器创建好后，即可调用调度器的schedule方法向调度器添加调度任务，但此时调度器并不会立刻执行这些任务，而是将它们保存到内部的一个任务队列中。

调用start方法启动调度：start方法调用后会创建调度线程池，线程数量由初始化时的线程数和use_caller确定。调度线程一旦创建，就会立刻从任务队列里取任务执行。比较特殊的一点是，**如果初始化时指定线程数为1且use_caller为true，那么start方法什么也不做**，因为不需要创建新线程用于调度。并且，由于没有创建新的调度线程，那只能由caller线程的调度协程来负责调度协程，而caller线程的调度协程的执行时机与start方法并不在同一个地方。

调度协程，对应run方法。调度协程负责从调度器的任务队列中取任务执行。取出的任务即子协程，这里调度协程和子协程的切换模型即为前一章介绍的非对称模型，每个子协程执行完后都必须返回调度协程，由调度协程重新从任务队列中取新的协程并执行。如果任务队列空了，那么调度协程会切换到一个idle协程，这个idle协程什么也不做，等有新任务进来时，idle协程才会退出并回到调度协程，重新开始下一轮调度。

**在非caller线程里，调度协程就是调度线程的主协程，但在caller线程里，调度协程并不是caller线程的主协程，而是相当于caller线程的子协程**

添加调度任务，对应schedule方法，这个方法支持传入协程或函数，并且支持一个线程号参数，表示是否将这个协程或函数绑定到一个具体的线程上执行。如果任务队列为空，那么在添加任务之后，要调用一次tickle方法以通知各调度线程的调度协程有新任务来了。

执行调度任务时，还可以通过调度器的`GetThis()`方法获取到当前调度器，再通过schedule方法继续添加新的任务，这就变相实现了在子协程中创建并运行新的子协程的功能。

调度器的停止。调度器的停止行为要分两种情况讨论，首先是use_caller为false的情况，这种情况下，由于没有使用caller线程进行调度，那么只需要简单地等各个调度线程的调度协程退出就行了。**如果use_caller为true，表示caller线程也要参于调度，这时，调度器初始化时记录的属于caller线程的调度协程就要起作用了，在调度器停止前，应该让这个caller线程的调度协程也运行一次，让caller线程完成调度工作后再退出。**如果调度器只使用了caller线程进行调度，那么所有的调度任务要在调度器停止时才会被调度。

**每个线程同时保存三个协程的上下文，一个是当前正在执行的协程上下文，另一个是线程主协程的上下文，最后一个是调度协程的上下文。有了这三个上下文，协程就可以根据自己的身份来选择和每次和哪个协程进行交换。**只有`useCaller`下的调度器所在的线程才有主协程(`rootFiber`)，其余在线程池中的线程的主协程也就是调度协程，无需区分。

1. 给协程类增加一个`bool`类型的成员`isRunInScheduler_`，用于记录该协程是否通过调度器来运行。

2. 创建协程时，根据协程的身份指定对应的协程类型，具体来说，只有想让调度器调度的协程的`isRunInScheduler_`值为`true`，线程主协程和线程调度协程的`isRunInScheduler_`都为`false`。

3. `resume`一个协程时，如果如果这个协程的`isRunInScheduler_`值为true，表示这个协程参与调度器调度，那它应该和三个线程局部变量中的调度协程上下文进行切换，同理，在协程yield时，也应该恢复调度协程的上下文，表示从子协程切换回调度协程；

4. 如果协程的`isRunInScheduler_`值为`false`，表示这个协程不参与调度器调度，那么在`resume`协程时，直接和线程主协程切换就可以了，`yield`也一样，应该恢复线程主协程的上下文。`isRunInScheduler_`值为false的协程上下文切换完全和调度协程无关，可以脱离调度器使用。

调度器的退出问题。调度器内部有一个协程任务队列，调度器调度的实质就是内部的线程池从这个任务队列拿任务并执行，那么，停止调度时，如果任务队列还有任务剩余，要怎么处理？这里可以简化处理，强制规定只有所有的任务都完成调度时，调度器才可以退出，如果有一个任务没有执行完，那调度器就不能退出。

只有main函数线程参与调度时的调度执行时机。前面说过，当只有main函数线程参与调度时，可以认为是主线程先攒下一波协程，然后切到调度协程开始调度这些协程，等所有的协程都调度完了，调度协程进idle状态，这个状态下调度器只能执行忙等待，啥也做不了。这也就是说，主线程main函数一旦开启了协程调度，就无法回头了，位于开始调度点之后的代码都执行不到。对于这个问题，`sylar`把调度器的开始点放在了stop方法中，也就是，调度开始即结束，干完活就下班。`IOManager`也是类似，除了可以调用stop方法外，`IOManager`类的析构函数也有一个stop方法，可以保证所有的任务都会被调度到。

 额外创建了调度线程时的调度执行时机。如果不额外创建线程，也就是线程数为1并且use caller，那所有的调度任务都在stop()时才会进行调度。但如果额外创建了线程，那么，在添加完调度任务之后任务马上就可以在另一个线程中调度执行。归纳起来，如果只使用caller线程进行调度，那所有的任务协程都在stop之后排队调度，如果有额外线程，那任务协程在刚添加到任务队列时就可以得到调度。

## IO协程调度模块

增强版的协程调度

IO协程调度解决了调度器在idle状态下忙等待导致CPU占用率高的问题。IO协程调度器使用一对管道`fd`来tickle调度协程，当调度器空闲时，idle协程通过`epoll_wait`阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。

IO协程调度支持协程调度的全部功能，因为IO协程调度器是直接继承协程调度器实现的。除了协程调度，IO协程调度还增加了IO事件调度的功能，这个功能是针对描述符（一般是套接字描述符）的。**IO协程调度支持为描述符注册可读和可写事件的回调函数，当描述符可读或可写时，执行对应的回调函数。**（这里可以直接把回调函数等效成协程，所以这个功能被称为IO协程调度）

对于IO协程调度来说，每次调度都包含一个三元组信息，分别是描述符-事件类型（可读或可写）-回调函数，调度器记录全部需要调度的三元组信息，其中描述符和事件类型用于`epoll_wait`，回调函数用于协程调度。这个三元组信息在源码上通过`FdContext`结构体来存储，在执行`epoll_wait`时**通过`epoll_event`的私有数据指针`data.ptr`来保存`FdContext`结构体信息**。

IO协程调度器在idle时会`epoll_wait`所有注册的`fd`，如果有`fd`满足条件，`epoll_wait`返回，**从私有数据中拿到`fd`的上下文信息，并且执行其中的回调函数**。（实际是idle协程只负责收集所有已触发的`fd`的回调函数并将其加入调度器的任务队列，真正的执行时机是idle协程退出后，调度器在下一轮调度时执行）

## 定时器模块

## hook模块

hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的`API`都转成异步，以提高性能。hook和IO协程调度是密切相关的，如果不使用IO协程调度器，那hook没有任何意义。

如果不使用hook，协程只能按顺序调度，一旦有一个协程阻塞住了，那整个调度线程也就阻塞住了，其他的协程都无法在当前线程上执行。使用hook后，以sleep为例，调度器完全可以在检测到协程sleep后，将协程yield以让出执行权，同时设置一个定时器，2秒后再将协程重新resume。

## 协程的生命周期流程

### 1.创建新协程 

调用`Fiber::Fiber(std::function<void()> cb, size_t stacksize, bool run_inscheduler)`，为新协程分配栈空间，设置好新协程的上下文和执行函数，便于后面切换。

### 2.调度器启动

`Scheduler::start()` 初始化调度线程池，（`threadCnt_`个线程）

在Scheduler构造函数中，调用`GetThis()`得到当前线程中的主协程，（若还没有会创建一个）然后设置当前线程的调度器协程。

对 **普通调度线程** 来说，`cur_scheduler_fiber` 是线程的**主协程**（就是线程启动后默认运行的 Fiber）

对 **caller 线程** 来说，`cur_scheduler_fiber` 是 `rootFiber_`，也就是手动创建的调度协程（它本质上不是主协程，而是一个普通 Fiber）

当协程yield后，在普通线程中，肯定是切换回线程的主协程，而在caller线程中，要根据`isRunInScheduler_`来判断切换到主协程还是调度协程。

### 3.协程调度运行

`caller`的调度器 协程 或者线程池`threadPool_`中 线程 的入口函数是`Scheduler::run()`

调用`Scheduler::run()`的如果不是caller线程 就会 初始线程的`cur_scheduler_fiber`（从其他协程 yield 回来要恢复到的协程），然后从任务队列中取出要在当前线程中执行的任务（协程或函数），统一将任务封装成协程进入运行态 即调用`Fiber::resume()`。（切换到运行态后，怎么执行`cb()`的？更换上下文后，包括了函数栈帧，会开始（或继续之前）调用协程入口函数`Fiber::MainFunc()`），`Fiber::MainFunc()`里的`cb()`运行完后，协程变为TERM态，然后`yield()` 返回cur_scheduler_fiber。

### 4.协程挂起/让出执行权

`Fiber::yield()` → 切换回cur_scheduler_fiber。